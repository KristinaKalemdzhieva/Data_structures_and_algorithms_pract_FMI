# Практикум 0: Преход от УП/ООП към СД

## Защо е необходимо да познаваме и използваме структури от данни?
За да отговорим на този въпрос, ще разгледаме задачата **Two Sum**.

>### Условие:
Даден е масив от цели числа **nums** и цяло число **target**. Да се реализира функция, която връща индексите на два елемнта от nums, чиято сума е равна на **target**.

Всеки вход ще има точно едно решение и не може да се използва един и същи елемент два пъти.

> ### Пример:
    Вход: nums = [2,7,11,15], target = 9
    Изход: [0,1] -> защото nums[0] + nums[1] == 9

>### Първи начин за решение на задачата:
Абстрахираме се от всички структури от данни и техники, които знаем, и работим само с предоставените данни.

Взимаме елемента на позиция **i** и проверяваме дали съществува елемент надясно от **i**
( *нека кажем, че този елемент стои на позиция j, j>i* ), сумата на които два елемента дава **target**
( *arr[i] + arr[j] ==? target, j > i* ).
- Ако успеем да намерим такава двойка елементи, връщаме двата индекса **i** и **j**.
- В противн случай, връщаме ***-1***.

Сложността на този алгоритъм е **Θ(N^2)**,
защото броят на сравненията е:

    n + (n-1) + (n-2) + ... + 1 = [n * (n+1)] / 2
Това принадлежи към **Θ(N^2**).

>### Втори начин за решение на задачата:
Има начин да подобрим сложността на алгоритъма.
За целта създаваме масив с наредени двойки от типа **{число, индекс}**.
След това сортираме във **възходящ ред** масива **по първия елемент** на наредената двойка - числото.
След сортирането, индексите ще бъдат разбъркани. Създаваме два указателя - ляв и десен,
които първоначално сочат към първата и последната наредена двойка респективно.
Проверяваме каква е сумата на двете числа, към които има указатели - **arr[left].first** и **arr[right].first** :
- aко сумата е равна на **target**
( *arr[left].first + arr[right].first == target* ), връщаме индексите,
на които стоят тези числа - **arr[left].second** и **arr[right].second** 
- aко сумата е различна от **target** ( *arr[left].first + arr[right].first != target* ), проверяваме дали сумата е по-голяма от **target** :
  - ако да, то преместваме десния указател с един елемент наляво ( *right--* )
  - ако не, то премествамe левия указател с една позиция надясно ( *left++* )

⚠️ **Това защо се прави?**

Защото ако най-левият елемент е най-малкия,
а десният е най-големия - то ако съберем най-десния със следващия елемент отляво, гарантирано ще получим по-голяма сума, тъй като вторият елемент е по-голям от първия.
Аналгочино и за другия случай. Ако в даден момент двата указателя се разминат,
то в масива няма два елемента, чиято сума е равна на **target**, и съответно връщаме ***-1***.

Сложността е **Θ(N * log(N))**,
заради сортирането, **+ Θ(N)**, заради обхождането на масива с двата указатея,
което прави финалната сложност: **Θ(N * log(N))**.

>### Трети начин за решение на задачата:
За да сведем сложността до Θ(N), може да използваме някаква структура от данни,
която да ни казва ако сме на някое число - текущо, то дали до този момент сме срещнали,
число, което ако добавим към текущото, ще получим **target**.

В структурата от данни пазим числото и индекса, на който стои това число в масива.
Ако няма такова число, то добавяме текущото и индекса му в структурата от данни.
<br/><br/>
**Алгоритъм:** <br/>
differenceToTarget = target - current; <br/>
if (dataStrucute.contains(differenceToTarget)) - *връщаме индекса на **current** и този на **числото** в структурана от данни*

Сложността е **Θ(N)**, защото обхождаме масива само един път,
а тази *"магическа"* структура от данни ни позволява да провевирм дали има елемент за **Θ(1)**.

>### Извод:
Използването на структури от данни значително подобрява сложността на кода.

## Задачи:
- [Линк към задачите](https://leetcode.com/problem-list/auwebgfe/)
