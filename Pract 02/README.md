# Практикум 2: Бързи сортировки

## Merge Sort (Сортиране чрез сливане)
Идеята на този алгоритъм е да разделим масива на 2 части, които да сортираме поотделно и накрая сливаме в един общ масив.

>#### Алгоритъм:
1) Делим масива на две части
2) Повтаряме стъпка 1. за всеки подмасив, докато не останат само подмасиви с по 1 елемент.
3) Сливаме подмасивите в общ масив, който е в сортиран вид

>#### ❕**ЗАБЕЛЕЖКА**❕**При делението на масивa:**
>Ако масивът има <span style="color:red">**четен**</span> брой елементи - делим го на две равни части. Ако масивът има <span style="color:red">**нечетен**</span> брой елементи - делим го на 2 части, като средният елемент слагаме в лявата част.

**Пример за сортиране на масив от цели числа чрез Merge Sort:** 
![](Images\mergeSortExample.jpg)

>#### Сложности:
- Сложност по памет: <span style="color:red">**Θ(n)**</span>
- Сложност по време: **Θ(n * log(n))**

>#### Имплементация:
 - [Имплементация с custom-made merge функция](mergeSort.cpp)
 - [Имплементация със std::merge функция](mergeSortUsingStdMerge.cpp)

## Quick Sort (Бързо сортиране)
Алгоритъм на принципа Разделяй и Владей. 
>#### Как работи?
Определяме един елемент като **pivot** ( *обикновено последния* ). Целта ни е да намерим такова място на **pivot**, че всички елементи наляво да са по-малки или равни, а тези надясно да са по-големи. Това става с два указателя ( *за случай, когато **pivot** е последният елемент* )- ще наричам помощния указател **swapper**, който ще сочи към елемента, който е свободен за размяна, а другият ще бъде просто **j**. **j** ще се движи по елементите и започва от първия елемент на подмасива, а **swapper** ще се движи само при размяна и започва една позиция преди началната позиция на **j**. Когато **j** намери число, което е по-малко или равно на pivot, увеличаваме swapper с 1 и разменяме двата елемента. j не проверява последния елемент на подмасива, защото там стои pivot. След края на итерациите, на позиция swapper+1 е правилното място, на което трябва да отиде pivot. Разменяме ги и изпълняваме същия алгоритъм за левия подмасив и десния подмасив спрямо pivot.
Средната сложност е O(N*LogN), а в най лошия, може да достигне до O(N^2), при сортиран масив или лош pivot.

## Задачи:
- [Линк към задачите](https://leetcode.com/problem-list/a72pyio7/)
- [Линк към допълнителни задачи](https://leetcode.com/problem-list/auwroke7/)

